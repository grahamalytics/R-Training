---
title: "Intro to R: Operators, Objects, Subsetting"
author: "Prepared by Graham Landry for Brierley+Partner's Consumer Insights Team"
date: "April 3rd, 2017"
output: slidy_presentation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r objinfo, include=FALSE, echo = FALSE}

objinfo <- function(x) {
    
    cls <- class(x)
    md <- mode(x)
    
    c <- noquote(paste("Class:", cls, sep = " "))
    m <- noquote(paste("Mode:", md, sep = " "))
    
    writeLines(c(c, m))
}

objectstr <- function(x) {
    if(is.list(x)) {
        mystr <- str(x[1])
    } else {
       mystr <- str(x) 
    }
    
    return(mystr)
}
```

## What to Expect from Today
Getting started with R is much like getting started with any programming language: you can start by reading the friendly manuals (RTFM), or scrolling through Stack Overflow and various blogs in order to find the syntax you are needing at that moment for that particular problem.

While the second method is inherently *faster* in the short term, the first method develops a better *foundation* for understanding a language and will increase the velocity in which you progress through a languge's learning curve.

My own journey through R follows the first path, it was (and continues to be) a slow and tedious process not for the faint of heart. You will easily find yourself reading hundreds of pages from various manuals and books on the R language, refining your understanding of R with each pass through material. 

Here, in this training, I've attempted to extract the core concepts from these various sources and summarize them in a way that is convenient for anyone getting started with R. A list of these resources will be provided at the end, in case you wish to do some additional reading. But at the end of the day, **pratice trumps reading everytime**. True learning will come from using the R language, not just reading about it.

## Full Disclosure
Today's training might be (most likely will be) dry...at the end of day we're talking about data structures for goodness sake! BUT, having the patience to complete this material, and understand it, will pay dividends for you down the road through your journey with R.

Many painstaking hours (but not all!) of debugging code and reading blogs online can be prevented by gaining a solid understanding of R's data structures. As a beginner, many of the error and warning messages you'll encounter will center around a mistmatch of the command and the *type* of object the command is called upon. Understanding R's data structures is imperative for understanding how and why R behaves like it does.

Finally, I've included several code examples to accompany the concepts presented herein. Similar to other programming languages, there are different paths (methods) to arriving at the same end-destination (objective). The examples to follow show some of the most common methods in R, but are by no means an exhaustive list/the only way to acheive a desired outcome.

## Topics for Today's Training
- A high-level introduction to R and the R environment
- R Operators
- Variable Assignment in R
- R Data Types
- R Data Structures
- Testing and Coercing Objects in R
- Subsetting Operators in R
- Generating Sequences in R
- Vectorized Operations and the Recycling Rule
- List of helpful functions when getting started with R
- Finding help with R

## Introduction to the R Language
The following excerpt comes from *An Introduction to R* by Venables, Smith, and the R Core Team:

R is an integrated suite of software facilities for data manipulation, calculation, and graphical display. Among other things it has:

- an effective data handling and storage facility
- a suite of operators for **calculations on arrays**, in particular matrices
- a large, coherent, integrated collection **tools for data analysis**
- **graphical facilities** for data analysis and display, and
- a well developed, **simple and effective programming language** which includes conditionals, loops, user-defined recursive functions and input/output facilities.
<center>![](C:\Users\glandry\Desktop\Projects\R-Training\assets\img\how-R-works.png)</center>
<center>*Figure 1.1: How R Works*</center>

## Things to Know Before Using R
In general:

- R is open source!! [Comprehensive R Archive Network (CRAN)](https://cran.r-project.org/)
- R stores all data in active memory, so don't overload it!
- The power and popularity of R is driven largely by the vast collection of **packages**  available for download. Packages are a collection of reusable R functions, documentation, and sample data or code examples. They are often specialized for a certain objective or topic (i.e. data wrangling, graphics, predictive modeling, time-series, bio-informatics, etc.)

Syntax:

- R is **case sensitive**
- Commands can be separated either by a new line or ;
- Given an object x, print(x) and x will yield the same output to the console.
- Commenting in R is done with the # symbol

## R Operators
The R language includes a full inventory of operators commonly used in data analysis. These operators can be divided in three categories: 

1. Arithmetic
2. Comparison
3. Logical

<center>![](C:\Users\glandry\Desktop\Projects\R-Training\assets\img\R-operators.png)</center>

<center>*Figure 1.2: Categorized R Operators*</center>

R's operators are designed for use on vectors and matrices/arrays. If you add together two vectors of the same length, the result vector will be a vector of the same length containing the element-by-element sum of the operand vectors. This will become more apparent in later slides.

In addition to these well-known operators, R has a 

## Example: Arithmetic in R
```{r eg_arithmetic}
# Some of the usual suspects
5 + 10; 
5 / 10
5^10
10 == 5

# Using TRUE and FALSE with Operators
TRUE + TRUE; TRUE + FALSE; FALSE + FALSE; TRUE / FALSE; FALSE / FALSE; TRUE == FALSE

```

## Sidenote: Boolean Values in R
A nice feature within R is the handling of Boolean values. TRUE and FALSE can be represented numerically as 1 and 0, respectively. This convenience allows for some useful operations to be performed on logical vectors: 

- applying **sum(...)** to a logical vector returns the total number of TRUE records.
- calling **mean(...)** upon a logical vector returns the proportion of TRUE records.

Both of these concepts will be illustrated in later slides for clarity.

## Sidenote: Missing & Special Values in R
Being that R is a statistical programming language, the manner in which it treats missing values is nuanced:

- **NA**: a special value in R representing that the value exsists but is unknown.
- **NULL**: represents that the value in question does not exist.
- **NaN**: Not-a-Number, what will be returned to the console if you enter 0/0
- **Inf**: Infiniti, what will be returned to the console if you enter 1/0

In fact, there are several *flavors* of **NA** values, but that level of detail is outside the scope of today's focus.

## Variable Assignment in R
The assignment operator in R is **<-** and *points* towards the object receiving the value. You may come across scripts using **=** as the assignment operator, which will work in most contexts but is generally discouraged as it can lead to confusion with the equality operator (==).

Object names can contain letters, numbers, and the . or _ characters but must start with a letter, or the dot not followed by a number. Also, be sure to avoid reserved words (see ?Reserved)

Assignments can be done from left to right or right to left, making the following assignments equivalent:

```{r}
greet <- "Hello, world!"

"Hello, world!" -> greet2

greet; greet2

```

## Example: Variable Assignment
```{r eg_variables}
# Assign values to a variable, pay attention to how your environment changes!!
x <- 21
y <- 7

x; y

x / y

# Variables are mutable and can be defined by other objects (even themselves!)
x <- x + 7

x

x / y

# view objects in workspace with either the objects(...) or ls(...) commands
objects()
ls()

# remove objects from workspace (cleanup!)
rm(x, y)
```

## Data Types in R
R's data types (modes) are very similar to those found in other common programming languages.

<center>![](C:\Users\glandry\Desktop\Projects\R-Training\assets\img\data-types.png)</center>

<center>*Figure 1.3: List of R Data Types*</center>

- If you need a number to be represented and identified as an integer, you must follow the numeric by the character 'L'. For example, 3 is a numeric (real number) whereas 3L is an integer.
- When using character strings in R, one can use either single or double quotes.
- TRUE and FALSE are recognized as logicals, which differ from True and False (not recognized as logicals). **Remember that R is case sensitive**

## Data Structures in R: Object Orientation
**Having a good understanding of R data structures is important because of R's "under the hood" implementation of object-oriented programming.** This means that calling the same function on different objects can yield different results, depending upon the type of objects supplied to the function. This is readily apparent with the **plot(...)** command.

```{r}
# create two numeric vectors for plotting
# x will contain 50 random variables from the standard normal distribution
# y will contain the numbers 1 through 50, by 1
x <- rnorm(n = 50)
y <- seq(from = 1, to = 50, by = 1)

# create a list object containing both x and y
xy <- list(x = x, y = y)

# create a histogram object for object x
xhist <- hist(x, plot = FALSE)

# notice the differences in plot() based upon the object
plot(xy)
plot(xhist)

# clean workspace
rm(x, y, xy, xhist)
```


## Data Structures in R: Everything is an Object
R operates on named data structures, called objects, and (as we just saw) the class/type of an object can effect the behavior of a function. R's different data structures include:

- Atomic Objects - can only contain *one* data type
    - **Vectors**: an ordered collection of elements that are all the same type; known as "atomic" data structures since their components are of the same type.
    - **Matrices**: 2-dimensional (n x m) generalizations of vectors. Matrices are a special case of arrays.
    - **Arrays**: multi-dimensional generalizations of vectors (e.g. n x m x z)
    
- Multi-mode Objects - can contain *multiple* data types
    - **Lists**: a general form of a vector in which various elements need not be of the same type
    - **Data Frames**: tabular data structures in which the columns can be of different types (think spreadsheet)

- **Factors**: a vector object used to represent categorical data (categories referred to as *levels*). A special type of factor, **ordered**, assumes that there is a natural ranking to the categories.
- **Functions**: package-defined and user-defined functions are themselves objets in R which can be stored in the project's workspace.

**Note** there are no true **scalar** (0-dimensional) data types within R. Instead, scalars are stored as single-element vectors.

**Note** there is another object type known as **expressions** which will not be covered here, but a quick Google search will return several results to satisfy your curiosity.


## Object Attributes
All R Objects are associated with **attributes** (think metadata). Objects can have both standard attributes and user-defined attributes, some of the most common being:

1. **Names**: a character vector giving each element of an object a name. 
    - This attribute can be used to refer to an object's elements by name rather than position.
2. **Dimensions**: a numeric vector providing the dimensionality for an object.
    - Useful in turning vectors into matrices and arrays, as well as during subsetting operations.
3. **Class**: the type of data object. For atomic vectors this is simply the type of vector (i.e. *numeric*, *complex*, *logical*, *character*, *raw*) but *factor*, *matrix*, *array*, *data.frame*, and *function* are other posisble values.

<center>![](C:\Users\glandry\Desktop\Projects\R-Training\assets\img\object-classes.png)</center>

4. **Length**: the number of elements or components of an object.

You can return a complete list of an object's attributes with the **attributes(...)** command. Alternatively, you can access particular attributes with the **names(...)**, **dim(...)**, **class(...)**, or **length(...)** commands.

## Example: Vectors
Atomic vectors are most often created using the combine function **c(...)**

**Remember** Vectors are an *ordered* collection of elements.
```{r}
# Create vectors using concatenation
days <- c("Mon", "Tue", "Wed", "Thurs", "Fri", "Sat", "Sun")
revenues <- c(1000, 1200, 7500, 9000, 15000, 20000, 18000)
expenses <- c(1000, 2000, 3500, 1250, 5000, 10000, 8000)
headcount <- c(5L, 5L, 5L, 6L, 10L, 10L, 8L)

# Vectors can also be created from other vectors
profitloss <- revenues - expenses
profitflag <- revenues > expenses

# Create a list to store all vectors just created
store <- list(days = days, revenues = revenues, expenses = expenses, 
               headcount = headcount, profitloss = profitloss, 
               profitflag = profitflag)

# look at structure of store list, whose components are all vectors themselves
str(store)
```

## Example: Assigning Names to a Vector
There are several methods for assigning names to elements of a vector, and the two most common methods are shown below:
```{r}
# print the revenue and days vecotrs just created
# remember each of the elements for these vectors corresponds to a different day
days; revenues

# assign names to the revenue vector using the names(...) command
names(revenues) <- days

# print revenues vector now to see what changed
revenues

# alternatively, we could have assigned names to the revenues vector this way
revenues2 <- c("Mon" = 1000, "Tues" = 1200, "Wed" = 7500, "Thurs" = 9000,
               "Fri" = 15000, "Sat" = 20000, "Sun" = 18000)
revenues2

# if needed, you can remove the names of a vector
names(revenues) <- NULL
revenues

# clean workspace
rm(revenues2)

```


## Example: Matrices
Create a matrix either with the **matrix(...)** command or by assigning a dimension attribute to an atomic vector with the **dim(...)** command.

**Remember** matrices are restricted in the sense that all columns must be the same data type.
```{r}
# create a matrix with cbind() which binds together two objects as columns
finances <- matrix(c(revenues, expenses), nrow = 7, ncol = 2, 
                   dimnames = list(NULL, c("Revenues", "Expenses")))
print(finances)

str(finances)

report <- cbind(days, revenues, expenses)
print(report)

str(report)
```


## Example: Arrays
The **array(...)** command can be used to create an array, and so can assigning a dimension attribute to a vector with the **dim(...)** command.
```{r}
# create an array with array()
finarray <- array(finances, dim = c(7, 1, 2), 
                  dimnames = list(NULL, NULL, c("Revenues", "Expenses")))

finarray

str(finarray)

# convert revenues vector to character and recreate an array to demonstrate that
# all columns must be of the same class within an array
rev_char <- as.character(revenues)

reparray <- array(c(revenues, expenses), dim = c(7,1,2), 
                  dimnames = list(days, NULL, c("Revenues", "Expenses")))

reparray

str(reparray)
```

## Example: Factors
Factors are created in R using the **factor(...)** command, and ordered factors can be created using the **ordered(...)** command.

**Remember** factors are built upon integer values, so even though they may look like character strings remember "under the hood" they are actually stored as integers.
```{r factors}

students <- c("Joe", "Paul", "Frank", "Greg", "Rich",
              "Polly", "Lauren", "Amy", "Kristi", "Rebecca", mode = "character")

ages <- c(22, 45, 30, 56, 42, 33, 62, 35, 19, 27)

agegroups <- c("Millennial", "GenX", "Millennial", "Boomer", "GenX",
               "Millennial", "Boomer", "GenX", "Millennial", "Millennial")

genders <- c("M", "M", "M", "M", "M", "F", "F", "F", "F", "F")

# coerce agegroups and genders variables to factors
agegroupsf <- ordered(agegroups, levels = c("Millennial", "GenX", "Boomer"))

gendersf <- factor(genders, levels = c("M", "F"))

# print new factor variables
agegroupsf; gendersf

# apply the str(...) command both factors, do you see how the factors are 
# represented as integers? What do you see that is different btw the two? 
str(agegroupsf); str(gendersf)

# show use case of factors by returning average age by age group and gender
tapply(ages, agegroups, mean)

tapply(ages, gendersf, mean)
```


## Example: Lists
Lists are created in R using the **list(...)** command.

You may see lists refered to as **recursive vectors** because a list can contain components that are also lists.

**Remember** lists are an ordered collection of components.

```{r}
# print store list to the console as well as the output from str(...)
print(store); str(store)

# verify that lists are recursive
is.recursive(store)

# does this mean vectors are recursive too?
is.recursive(days)

# the unlist(...) command 'unpacks' a list into vectors and prints the result. 
# For simplicity, let's remove the names of the list components before using
# unlist(...)
names(store) <- NULL
unlist(store)
```


## Example: Data Frames
Create Data Frames in R using the **data.frame(...)** command.

**Remember** data frames are lists of equal-length vectors with class of *data.frame*. They differ from matrices in that they can include columns of different modes.
```{r}
storedf <- data.frame(days = days, revenues = revenues, expenses = expenses,
                      profitloss = profitloss, profitflag = profitflag)

print(storedf)

str(storedf)
```

## Testing and Coercion of Objects in R
From vectors to data frames, you've now been introduced to R's major data structures.

Sometimes, it is helpful to test for a certain data type or coerce an object from one type to another. The commands for testing and coercing objects are summarized below (along with the commands to create the objects):

<center>![](C:\Users\glandry\Desktop\Projects\R-Training\assets\img\type-testing-coercion.png)</center>

<center>*Figure 1.3: R Commands for Creting, Testing, and Coercing Objects*</center>


## Subsetting Objects
R has three operators for subsetting objects in the workspace:

- **[** returns results simplified to lowest possible dimension.
- **[[** returns only a single value, allows user to pull pieces out of a list.
- **$** shorthand for using [[ subsetting with a character string (assumes object has been assigned names).

With these operators, you can subset a vector using the following:

- **Positive Integers**: will return the elements at the specified positions.
- **Negative Integers**: will omit elements at the specified positions.
- **Logical Vectors**: will select the elements where the corresponding logical value is TRUE.
- **Character Vectors**: will return the elements with matching names (implies names have been assigned to an object's elements).

## Simplifying and Preserving with Subsetting

<center>![](C:\Users\glandry\Desktop\Projects\R-Training\assets\img\subset-simplify-preserve.png)</center>

## Example: Subsetting Vectors
```{r}
# print complete vector
revenues

# print first element of vector
revenues[1]

# print a subset of only the 2nd and 5th elements
revenues[c(2, 5)]

# print a subset of the 2nd, 3rd, and 4th elements
revenues[2:4]

# print a subset of all elements but the 3rd element
revenues[-3]

# subset sales returing only sales on profitable days using logical vector
profitflag

revenues[profitflag]
```


## Example: Subsetting Matrices and Arrays
The following subsetting examples are performed on matrices. While no examples for subsetting arrays will be explicitly provided, understand that the same concepts for subsetting matrices generalize to subsetting arrays (with the difference being the added dimensions of an array).

```{r}
# view matrix
finances

# return the entire "cost" column
finances[,2, drop = FALSE]

finances[,2]

# return the first row of the matrix
finances[1,]

# return the element found in the 3rd row, 2nd column of the matrix
finances[3,2]

# return the 8th element of the matrix (col major order)
finances[8]

# explore same concepts with array
```


## Example: Subsetting Lists
```{r}
# view store list
store

# print the first component of the list as a list
store[1]

class(store[1])

# print the first component of the list as a vector
store[[1]]

class(store[[1]])

# print the second component of the list by name
store["revenues"]

store[["revenues"]]

# print the third element of the second component of the list
store["revenues"][[1]][2]

store$revenues[2]

# note that components of lists can be accessed either by number or by name (if names are assigned)
store[1]

store$days

```

## Example: Subsetting Data Frames

## Generating Sequences in R
show both the seq() function as well as distributions

## Vectorized Objects and the Recycling Rule
Operators in R are vectorized, meaning that they are designed to perform operators on two (or more) vectors or matrices.

The **recycling rule** refers to when, in the case of one object being shorter in length than the other, elements of the short object are re-used (recycled) to complete the operation on the remaining elements of the longer object.
```{r}
x <- seq(from = 1, to = 10, by = 1)

y <- seq(from = 1, to = 20, by = 2)

z <- seq(from = 1, to = 5, by = 1)

x; y; z

x + y

x - z

```

## Helpful Functions
cbind()
rbind()
c()
is.___ for checking vector type
coercion functions
unlist()
which.min & which.max
na.omit(...)
subset()
tolower()
toupper()

## Help with R
If you ever find yourself wanting more information surrounding objects, fucntions, data structures, packages, or anaything else, try these resources:

- help(...)
- help.star(...)
- ?...
- ??...
- CRAN
- Stack Overflow
- R Email list

```{r include = FALSE}
# Inbuilt help facilities
#help(t)
#?t

#help.start() #HTML format to CRAN resources

#??mean # expanded help
```

## Where Do We Go From Here?


## Citations
```{r citations}

# Things to Know About R - Source: R for Beginners, pg. 4

# Arithmetic Operators - R for Beginners, pg. 25*

```

